document.addEventListener('DOMContentLoaded', () => {
    const jsonInput = document.getElementById('json-input');
    const goOutput = document.getElementById('go-output');
    const rootNameInput = document.getElementById('root-name');
    const usePointersCheck = document.getElementById('use-pointers');
    const clearBtn = document.getElementById('clear-btn');
    const copyBtn = document.getElementById('copy-btn');
    const errorDisplay = document.getElementById('error-display');
    const toast = document.getElementById('toast');

    let structs = [];

    const convert = () => {
        const input = jsonInput.value.trim();
        errorDisplay.style.display = 'none';
        structs = [];

        if (!input) {
            goOutput.value = '';
            return;
        }

        try {
            const parsed = JSON.parse(input);
            const rootName = formatTypeName(rootNameInput.value.trim() || 'AutoGenerated');
            const usePointers = usePointersCheck.checked;

            parseStruct(rootName, parsed, usePointers);

            goOutput.value = structs.join('\n\n');
        } catch (e) {
            errorDisplay.textContent = 'JSONのパースに失敗しました: ' + e.message;
            errorDisplay.style.display = 'block';
            goOutput.value = '';
        }
    };

    const parseStruct = (name, obj, usePointers) => {
        if (obj === null || typeof obj !== 'object' || Array.isArray(obj)) return;

        let structDef = `type ${name} struct {\n`;
        for (const key in obj) {
            const value = obj[key];
            const goKey = formatFieldName(key);
            const goType = inferGoType(value, name + goKey, usePointers);

            structDef += `\t${goKey} ${goType} \`json:"${key}"\`\n`;
        }
        structDef += '}';
        structs.push(structDef);
    };

    const inferGoType = (value, suggestedName, usePointers) => {
        const ptr = usePointers ? '*' : '';

        if (value === null) return 'interface{}';

        if (Array.isArray(value)) {
            if (value.length === 0) return '[]interface{}';
            const firstItem = value[0];
            if (firstItem !== null && typeof firstItem === 'object' && !Array.isArray(firstItem)) {
                const typeName = formatTypeName(suggestedName);
                parseStruct(typeName, firstItem, usePointers);
                return `[]${typeName}`;
            }
            return '[]' + inferGoType(firstItem, suggestedName, false);
        }

        if (typeof value === 'object') {
            const typeName = formatTypeName(suggestedName);
            parseStruct(typeName, value, usePointers);
            return ptr + typeName;
        }

        if (typeof value === 'string') return ptr + 'string';
        if (typeof value === 'boolean') return ptr + 'bool';
        if (typeof value === 'number') {
            return Number.isInteger(value) ? ptr + 'int' : ptr + 'float64';
        }

        return 'interface{}';
    };

    const formatFieldName = (str) => {
        return str
            .replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase())
            .replace(/^[a-z]/, (m) => m.toUpperCase())
            .replace(/[^a-zA-Z0-9]/g, '');
    };

    const formatTypeName = (str) => {
        return formatFieldName(str);
    };

    // Events
    jsonInput.addEventListener('input', convert);
    rootNameInput.addEventListener('input', convert);
    usePointersCheck.addEventListener('change', convert);

    clearBtn.addEventListener('click', () => {
        jsonInput.value = '';
        convert();
    });

    copyBtn.addEventListener('click', () => {
        if (!goOutput.value) return;
        navigator.clipboard.writeText(goOutput.value).then(() => {
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        });
    });

    // Initial
    if (jsonInput.value) convert();
});
