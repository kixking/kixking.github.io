/**
 * JSON to Go Struct Logic Module
 */
export const JsonToGoLogic = {
    /**
     * Convert JSON string to Go Struct
     * @param {string} jsonStr Raw JSON string
     * @param {string} structName Name of the root struct
     * @returns {string} Go struct definition
     */
    convert(jsonStr, structName = 'AutoGenerated') {
        if (!jsonStr) return '';
        let data;
        try {
            data = JSON.parse(jsonStr);
        } catch (e) {
            throw new Error('Invalid JSON');
        }

        return this._parseStruct(data, structName);
    },

    _parseStruct(data, name) {
        if (typeof data !== 'object' || data === null) {
            // Root is not an object, just array or primitive
            return `type ${name} ${this._getType(data)}`;
        }

        if (Array.isArray(data)) {
            // Root is array
            const type = data.length > 0 ? this._getType(data[0]) : 'interface{}';
            return `type ${name} []${type}`;
        }

        let lines = [];
        lines.push(`type ${name} struct {`);

        const keys = Object.keys(data);
        for (const key of keys) {
            const value = data[key];
            const fieldName = this._formatFieldName(key);
            const type = this._getType(value);
            const tag = `\`json:"${key}"\``;
            lines.push(`\t${fieldName} ${type} ${tag}`);
        }

        lines.push('}');
        return lines.join('\n');
    },

    _getType(value) {
        if (value === null) return 'interface{}';

        const type = typeof value;
        switch (type) {
            case 'string':
                return 'string';
            case 'number':
                return Number.isInteger(value) ? 'int' : 'float64';
            case 'boolean':
                return 'bool';
            case 'object':
                if (Array.isArray(value)) {
                    if (value.length === 0) return '[]interface{}';
                    // Check first element for type
                    const elemType = this._getType(value[0]);
                    return `[]${elemType}`;
                }
                // Nested object: simplify by making it inline struct or interface{}
                // For a robust tool, we might want to recurse properly, but for "simple",
                // let's try to generate an inline struct.
                return this._generateInlineStruct(value);
            default:
                return 'interface{}';
        }
    },

    _generateInlineStruct(data) {
        if (Object.keys(data).length === 0) return 'struct{}';

        let lines = ['struct {'];
        for (const key of Object.keys(data)) {
            const fieldName = this._formatFieldName(key);
            const type = this._getType(data[key]);
            const tag = `\`json:"${key}"\``;
            lines.push(`\t\t${fieldName} ${type} ${tag}`);
        }
        lines.push('\t}');
        return lines.join('\n');
    },

    _formatFieldName(key) {
        // Convert to PascalCase: "user_id" -> "UserId", "camelCase" -> "CamelCase"
        // Simple heuristic: uppercase first letter, handle underscores
        return key.replace(/(^|[_ \-])(.)/g, (match, sep, char) => char.toUpperCase());
    }
};
